<html>
<head>
  <title>.osu to .chart, but why</title>
</head>
<body>
<script>
const MIN_MULT = 0.0001;
// Most likely mp3 overhead idk
var DUMB_OFFSET = 0;

const convert = source => {
  const lines = source.split("\n");
  const timingPointsIndex = lines.findIndex(line => line.includes("[TimingPoints]"));
  const hitObjectsIndex = lines.findIndex(line => line.includes("[HitObjects]"));

  const bpms = [];
  const svs = [];
  lines.slice(timingPointsIndex, hitObjectsIndex).forEach(line => {
    const [ms, value] = line.split(',');
    if (value == null) return;
    if (value < 0) {
      svs.push({ value: Math.round(10000 / (-value)) / 100, ms: +ms });
    } else {
      if (bpms.length < 1) bpms.push({ bpm: Math.round(60000 / (+value)), ms: +ms });
    }
  });

  // Hypothetically, .osu "indexes" are their positions in milliseconds (arguably terrible)
  // The cheap strategy (for now) is to go by PRECISION, compute time and grab the ones that match

  // Notes:
  // 64 = 1, 192 = 2, 320 = 3, 448 = 4

  // in the last x:x:x:x:x: group, the first number is the timestamp where the sustain should stop
  const osuNotes = {};
  lines.slice(hitObjectsIndex).forEach(line => {
    const [noteId,, time,,, rest] = line.split(",");
    if (!time) return;
    const [end] = rest.split(':');
    if (!osuNotes[time]) osuNotes[time] = [];
    const noteObj = {
      note: {
        64: 1,
        192: 2,
        320: 3,
        448: 4
      }[noteId] || 2,
      end: +end || undefined
    };
    osuNotes[time].push(noteObj);
    if (+end) {
      if (!osuNotes[+end]) osuNotes[+end] = [];
      osuNotes[+end].push({
        isEnd: true,
        note: {
          64: 1,
          192: 2,
          320: 3,
          448: 4
        }[noteId] || 2,
        ref: noteObj
      });
    }
  });

  const times = Object.keys(osuNotes).sort((a, b) => Number(a) - Number(b));
  let leftoverTimes = [];
  let leftoverSvs = [];
  let leftoverBpms = [];
  const synctrack = [];
  const notes = [];
  let time = bpms[0].ms;
  const startTime = time;
  // Skip the first measure, assume the constant BPM from there
  // "24" is the 1/32 interval
  let bpm = bpms[0].bpm;
  let index = 384;
  let MARGIN = 2; // milliseconds
  const cycle = [1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 5, 10, 20, 40, 80, 7, 14, 28, 56, 9, 18, 36, 72, 11, 22, 44, 88, 13, 26, 52, 15, 30, 60, 128, 192, 256, 192*2, 512];
  while ((times.length || bpms.length || svs.length || leftoverTimes.length || leftoverSvs.length || leftoverBpms.length) && cycle.length) {
    if (cycle.length == 1) MARGIN = 5; // Last resort snapping
    const precision = Math.round((192*4) / cycle[0]);

    while (times.length && time >= times[0] - MARGIN) {
      const next = times.shift();
      if (time - next < MARGIN) {
        for (const n of osuNotes[next]) {
          const { isEnd, note, end, ref, noteRef } = n;
          if (!isEnd) {
            if (noteRef) {
              noteRef.index = index;
              if (noteRef.end) {
                noteRef.length = noteRef.end - index;
              }
            } else {
              n.noteRef = { index, note, length: 0 };
              notes.push(n.noteRef);
            }
          } else {
            if (ref.noteRef) {
              if (ref.noteRef.index) {
                ref.noteRef.length = index - ref.noteRef.index;
              } else {
                ref.noteRef.end = index;
              }
            } else {
              ref.noteRef = { note, end: index };
              notes.push(ref.noteRef);
            }
          }
        }
      } else {
        leftoverTimes.push(next);
      }
    }

    while (bpms.length && time >= bpms[0].ms - MARGIN) {
      const next = bpms.shift();
      if (time - next.ms < MARGIN) {
        synctrack.push({ index, bpm: next.bpm });
      } else {
        leftoverBpms.push(next);
      }
    }

    while (svs.length && time >= svs[0].ms - MARGIN) {
      const next = svs.shift();
      if (time - next.ms < MARGIN) {
        notes.push({ index, event: `sv:${next.value}` });
      } else {
        leftoverSvs.push(next);
      }
    }

    // time += <index delta> * 60 / (bpm * resolution)... but that's in seconds, so *1000
    time += (precision * 60000) / (bpm * 192);
    index += precision;

    if (!times.length && !bpms.length && !svs.length) {
      times.push(...leftoverTimes);
      bpms.push(...leftoverBpms);
      svs.push(...leftoverSvs);
      leftoverTimes = [];
      leftoverSvs = [];
      leftoverBpms = [];
      cycle.shift();
      index = 384;
      time = startTime;
    }
  }
  document.getElementById('log').innerHTML = `debug: last cycle:${cycle[0]} times left:${times.length} bpms left:${bpms.length} svs left:${svs.length}`;

  let txt = `[Song]
{
  Offset = 0
  Resolution = 192
  Player2 = bass
  Difficulty = 0
  PreviewStart = 0
  PreviewEnd = 0
  Genre = "rock"
  MediaType = "cd"
  MusicStream = "audio.mp3"
}
[SyncTrack]
{
  0 = TS 2
  0 = B 165671
  384 = TS 4
${synctrack.map(({ index, bpm }) => `  ${index} = B ${bpm*1000}`).join('\n')}
}
[Events]
{
}  
[ExpertDrums]
{
`;
  txt += notes.map(({ note, index, event, length }) => event ? `  ${index} = E ${event}` : `  ${index} = N ${note} ${length}`).join("\n");
  txt += "\n}";

  return txt;
};
</script>
.osu file <input type="file" id="chart" /><br />
<br />
<div id="log"></div>
<br /><br />
<a id="result" download="notes.chart" target="_blank">... Load something up there will you ...</a><br />
<textarea style="width:800px;height:500px" id="preview" placeholder="Result will appear below"></textarea>

<script>
  document.getElementById("chart").addEventListener('change', $event => {
    const fr = new FileReader();
    fr.addEventListener('loadend', () => {
      const converted = convert(fr.result);
      const blob = URL.createObjectURL(new Blob([converted], { type: 'application/chart' }));
      const link = document.getElementById('result');
      link.href = blob;
      link.innerHTML = 'Click to download';
      document.getElementById('preview').value = converted;
    });
    fr.readAsText($event.target.files[0]);
  });
</script>
</body>
</html>
